package dev.ua.theroer.magicutils;

import dev.ua.theroer.magicutils.lang.LanguageManager;
import dev.ua.theroer.magicutils.logger.LogLevel;
import lombok.Getter;
import lombok.Setter;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.minimessage.MiniMessage;
import net.kyori.adventure.text.format.TextDecoration;

import dev.ua.theroer.magicutils.config.ConfigManager;
import dev.ua.theroer.magicutils.config.SubLoggerConfig;
import dev.ua.theroer.magicutils.config.logger.LoggerConfig;
import dev.ua.theroer.magicutils.utils.ColorUtils;
import dev.ua.theroer.magicutils.logger.LogBuilder;
import dev.ua.theroer.magicutils.logger.LogDispatcher;
import dev.ua.theroer.magicutils.logger.LogMessageFormatter;
import dev.ua.theroer.magicutils.logger.LogMethods;
import dev.ua.theroer.magicutils.logger.PrefixedLogger;
import dev.ua.theroer.magicutils.logger.PrefixMode;
import dev.ua.theroer.magicutils.logger.LogTarget;

import org.bukkit.entity.Player;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.command.CommandSender;

import javax.annotation.Nullable;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Utility class for logging messages to console and chat with color and
 * formatting support. All log level methods are generated by annotation
 * processor.
 */
@LogMethods
public final class Logger {
    @Getter
    private static LoggerConfig config;
    private static ConfigManager configManager;

    @Getter @Setter
    private static LanguageManager languageManager;

    // Prefix settings
    @Getter @Setter
    private static PrefixMode chatPrefixMode = PrefixMode.FULL;
    @Getter @Setter
    private static PrefixMode consolePrefixMode = PrefixMode.SHORT;
    @Getter @Setter
    private static String customPrefix = "[UAP]";

    // Default settings
    @Getter @Setter
    private static LogTarget defaultTarget = LogTarget.BOTH;
    @Getter @Setter
    private static boolean consoleStripFormatting = false;
    @Getter @Setter
    private static boolean consoleUseGradient = false;

    // Plugin instance for thread safety
    @Getter
    private static JavaPlugin pluginInstance;

    /**
     * Sets auto-localization state.
     * 
     * @param enabled true to enable auto-localization
     */
    public static void setAutoLocalization(boolean enabled) {
        if (config != null) {
            config.setAutoLocalization(enabled);
            configManager.save(LoggerConfig.class);
        }
    }

    @Getter
    private static final MiniMessage miniMessage = MiniMessage.miniMessage();
    @Getter
    private static final Map<String, PrefixedLogger> prefixedLoggers = new HashMap<>();

    /**
     * Default constructor (not used).
     */
    private Logger() {
    }

    /**
     * Initializes the logger with the plugin and configuration manager.
     * 
     * @param plugin  the JavaPlugin instance
     * @param manager the configuration manager
     */
    public static void init(JavaPlugin plugin, ConfigManager manager) {
        Logger.pluginInstance = plugin;
        Logger.configManager = manager;
        Logger.config = manager.register(LoggerConfig.class);

        // Set plugin name if not already set
        if (config.getPluginName().isEmpty()) {
            config.setPluginName(plugin.getName());
        }

        // Generate short name if not set
        if (config.getShortName().isEmpty()) {
            config.setShortName(generateShortName(config.getPluginName()));
        }

        loadConfiguration();

        // Save config with updated values
        manager.save(LoggerConfig.class);

        // Listen for config changes
        manager.onChange(LoggerConfig.class, (cfg, sections) -> {
            config = cfg;
            loadConfiguration();
        });
    }

    /**
     * Reloads the logger configuration.
     */
    public static void reload() {
        if (config != null) {
            loadConfiguration();
        }
    }

    /**
     * Load all settings from configuration
     */
    private static void loadConfiguration() {
        if (config == null)
            return;

        // Load prefix settings
        if (config.getPrefix() != null) {
            chatPrefixMode = config.getChatPrefixMode();
            consolePrefixMode = config.getConsolePrefixMode();
            customPrefix = config.getPrefix().getCustom();
            consoleUseGradient = config.getPrefix().isUseGradientConsole();
        }

        // Load default settings
        if (config.getDefaults() != null) {
            defaultTarget = config.getDefaultTarget();
        }

        // Load console settings
        if (config.getConsole() != null) {
            consoleStripFormatting = config.getConsole().isStripFormatting();
        }

        // Load sub-logger configurations
        loadSubLoggers();
    }

    /**
     * Generate short name from plugin name
     */
    private static String generateShortName(String name) {
        StringBuilder sb = new StringBuilder();
        Pattern pattern = Pattern.compile("[A-Z]");
        Matcher matcher = pattern.matcher(name);

        while (matcher.find() && sb.length() < 3) {
            sb.append(matcher.group());
        }

        if (sb.length() < 2) {
            sb = new StringBuilder();
            String[] words = name.split("(?=[A-Z])|[\\s_-]+");
            for (String word : words) {
                if (!word.isEmpty() && sb.length() < 3) {
                    sb.append(word.charAt(0));
                }
            }
        }

        return sb.toString().toUpperCase();
    }

    /**
     * Universal send method for logging messages with complete control over
     * delivery.
     * 
     * @param level        the log level (INFO, WARN, ERROR, DEBUG, SUCCESS)
     * @param message      the message to log (any Object)
     * @param player       single recipient player (can be null)
     * @param players      collection of recipient players (can be null or empty)
     * @param target       where to send (CHAT, CONSOLE, BOTH)
     * @param broadcast    if true, sends to all online players (ignoring
     *                     player/players params)
     * @param placeholders the placeholders to apply to the message
     */
    public static void send(
            LogLevel level,
            Object message,
            @Nullable Player player,
            @Nullable Collection<? extends Player> players,
            LogTarget target,
            boolean broadcast,
            Object... placeholders) {

        if (LogLevel.DEBUG == level && config != null && !config.isDebugCommands()) return;
        // Process the message into Component
        Component component = parseMessage(message, level, target, player, players, placeholders);

        // Determine recipients
        Collection<CommandSender> recipients = LogDispatcher.determineRecipients(player, players, broadcast, target);

        // Deliver the message
        LogDispatcher.deliver(pluginInstance, component, recipients, target);
    }

    /**
     * Creates a fluent log builder for info level messages.
     * 
     * @return a new LogBuilder instance for chaining
     */
    public static LogBuilder log() {
        return new LogBuilder(LogLevel.INFO);
    }

    /**
     * Creates a fluent log builder for info level messages with no prefix.
     * 
     * @return a new LogBuilder instance for chaining
     */
    public static LogBuilder noPrefix() {
        return new LogBuilder(LogLevel.INFO).noPrefix();
    }

    /**
     * Creates a fluent log builder for info level messages.
     * 
     * @return a new LogBuilder instance for chaining
     */
    public static LogBuilder info() {
        return new LogBuilder(LogLevel.INFO);
    }

    /**
     * Creates a fluent log builder for warning level messages.
     * 
     * @return a new LogBuilder instance for chaining
     */
    public static LogBuilder warn() {
        return new LogBuilder(LogLevel.WARN);
    }

    /**
     * Creates a fluent log builder for error level messages.
     * 
     * @return a new LogBuilder instance for chaining
     */
    public static LogBuilder error() {
        return new LogBuilder(LogLevel.ERROR);
    }

    /**
     * Creates a fluent log builder for debug level messages.
     * 
     * @return a new LogBuilder instance for chaining
     */
    public static LogBuilder debug() {
        return new LogBuilder(LogLevel.DEBUG);
    }

    /**
     * Creates a fluent log builder for success level messages.
     * 
     * @return a new LogBuilder instance for chaining
     */
    public static LogBuilder success() {
        return new LogBuilder(LogLevel.SUCCESS);
    }

    /**
     * Creates a new logger instance with custom prefix.
     * Usage: Logger.create("MyModule").info("Hello")
     * 
     * @param name the name of the prefixed logger
     * @return a new PrefixedLogger instance
     */
    public static PrefixedLogger create(String name) {
        return withPrefix(name);
    }

    /**
     * Creates a new logger instance with custom name and prefix.
     * Usage: Logger.create("MyModule", "[MODULE]").info("Hello")
     * 
     * @param name   the name of the prefixed logger
     * @param prefix the custom prefix to use in messages
     * @return a new PrefixedLogger instance
     */
    public static PrefixedLogger create(String name, String prefix) {
        return withPrefix(name, prefix);
    }

    /**
     * Parses any Object into a formatted Component with prefix based on settings.
     * 
     * @param message the message to parse
     * @param level the log level
     * @param target the target
     * @param directPlayer the direct player
     * @param playerCollection the player collection
     * @param placeholdersArgs the placeholders arguments
     * @return the parsed message
     */
    public static Component parseMessage(
            Object message,
            LogLevel level,
            LogTarget target,
            @Nullable Player directPlayer,
            @Nullable Collection<? extends Player> playerCollection,
            Object... placeholdersArgs) {
        return LogMessageFormatter.format(message, level, target, directPlayer, playerCollection, placeholdersArgs);
    }

    /**
     * Parses a string into a Component with smart parsing.
     * 
     * @param input the string to parse
     * @return the parsed Component
     */
    public static Component parseSmart(String input) {
        if (input == null || input.isEmpty())
            return Component.empty();
        boolean hasMini = input.indexOf('<') >= 0 && input.indexOf('>') > input.indexOf('<');
        boolean hasLegacy = input.indexOf('&') >= 0 || input.indexOf('ยง') >= 0;
        String source = input;
        if (hasLegacy) {
            source = ColorUtils.legacyToMiniMessage(source);
            hasMini = true;
        }
        Component comp = hasMini ? miniMessage.deserialize(source) : Component.text(source);
        if (comp.decoration(TextDecoration.ITALIC) == TextDecoration.State.NOT_SET) {
            comp = comp.decoration(TextDecoration.ITALIC, false);
        }
        return comp;
    }

    /**
     * Resolves colors for the specified log level directly from the active configuration.
     * Falls back to built-in defaults if the configuration isn't available yet.
     *
     * @param level log level being rendered
     * @param forConsole true to use console palette, false for chat palette
     * @return array of colors representing a gradient for the given level/target
     */
    public static String[] resolveColorsForLevel(LogLevel level, boolean forConsole) {
        LoggerConfig cfg = config;
        if (cfg == null) {
            return LoggerConfig.defaultColors(level);
        }
        return cfg.resolveColors(level, forConsole);
    }

    /**
     * Load prefixed logger configurations from config
     */
    private static void loadSubLoggers() {
        if (config == null || config.getSubLoggers() == null)
            return;

        for (Map.Entry<String, SubLoggerConfig> entry : config.getSubLoggers().entrySet()) {
            PrefixedLogger existing = prefixedLoggers.get(entry.getKey());
            if (existing != null) {
                existing.setEnabled(entry.getValue().isEnabled());
            }
        }
    }

    /**
     * Creates or gets a logger with custom prefix
     * 
     * @param name the name of the logger
     * @return the prefixed logger instance
     */
    public static PrefixedLogger withPrefix(String name) {
        return withPrefix(name, "[" + name + "]");
    }

    /**
     * Creates or gets a logger with custom prefix
     * 
     * @param name   the name of the logger
     * @param prefix the prefix to use
     * @return the prefixed logger instance
     */
    public static PrefixedLogger withPrefix(String name, String prefix) {
        return prefixedLoggers.computeIfAbsent(name, k -> {
            PrefixedLogger prefixedLogger = new PrefixedLogger(name, prefix);

            if (config != null && config.addSubLogger(name)) {
                configManager.save(LoggerConfig.class);
            }

            // Check if there's a configuration for this logger
            if (config != null && config.getSubLoggers() != null) {
                SubLoggerConfig subLoggerConfig = config.getSubLoggers().get(name);
                if (subLoggerConfig != null) {
                    prefixedLogger.setEnabled(subLoggerConfig.isEnabled());
                }
            }

            return prefixedLogger;
        });
    }

    /**
     * Sets the enabled state of a prefixed logger
     * 
     * @param name    the name of the logger
     * @param enabled true to enable, false to disable
     */
    public static void setPrefixedLoggerEnabled(String name, boolean enabled) {
        PrefixedLogger logger = prefixedLoggers.get(name);
        if (logger != null) {
            logger.setEnabled(enabled);
        }
    }
}
