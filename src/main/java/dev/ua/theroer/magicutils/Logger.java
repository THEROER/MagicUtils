package dev.ua.theroer.magicutils;

import dev.ua.theroer.magicutils.lang.LanguageManager;
import lombok.Getter;
import lombok.Setter;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.minimessage.MiniMessage;
import net.kyori.adventure.text.minimessage.tag.resolver.TagResolver;
import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
import net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer;

import org.bukkit.Bukkit;
import dev.ua.theroer.magicutils.config.ConfigManager;
import dev.ua.theroer.magicutils.config.SubLoggerConfig;
import dev.ua.theroer.magicutils.config.logger.LoggerConfig;
import dev.ua.theroer.magicutils.utils.ColorUtils;
import dev.ua.theroer.magicutils.utils.placeholders.PlaceholderProcessor;
import dev.ua.theroer.magicutils.logger.LogBuilder;
import dev.ua.theroer.magicutils.logger.LogMethods;
import dev.ua.theroer.magicutils.logger.PrefixedLogger;

import org.bukkit.entity.Player;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.command.CommandSender;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Utility class for logging messages to console and chat with color and
 * formatting support. All log level methods are generated by annotation
 * processor.
 */
@LogMethods
public final class Logger {
    @Getter
    private static LoggerConfig config;
    private static ConfigManager configManager;

    private static String[] chatDefaultGradient;
    private static String[] consoleDefaultGradient;

    private static String[] chatErrorColors;
    private static String[] chatWarnColors;
    private static String[] chatDebugColors;
    private static String[] chatSuccessColors;

    private static String[] consoleErrorColors;
    private static String[] consoleWarnColors;
    private static String[] consoleDebugColors;
    private static String[] consoleSuccessColors;

    @Setter
    private static LanguageManager languageManager;

    // Prefix settings
    private static PrefixMode chatPrefixMode = PrefixMode.FULL;
    private static PrefixMode consolePrefixMode = PrefixMode.SHORT;
    private static String customPrefix = "[UAP]";

    // Default settings
    private static Target defaultTarget = Target.BOTH;
    private static boolean consoleStripFormatting = false;
    private static boolean consoleUseGradient = false;

    // Plugin instance for thread safety
    private static JavaPlugin pluginInstance;

    /**
     * Sets auto-localization state.
     * 
     * @param enabled true to enable auto-localization
     */
    public static void setAutoLocalization(boolean enabled) {
        if (config != null) {
            config.setAutoLocalization(enabled);
            configManager.save(LoggerConfig.class);
        }
    }

    /**
     * Sets prefix modes for both chat and console.
     * 
     * @param chatMode    prefix mode for chat messages
     * @param consoleMode prefix mode for console messages
     */
    public static void setPrefixModes(PrefixMode chatMode, PrefixMode consoleMode) {
        chatPrefixMode = chatMode;
        consolePrefixMode = consoleMode;
    }

    /**
     * Sets prefix mode for chat messages.
     * 
     * @param mode the prefix mode
     */
    public static void setChatPrefixMode(PrefixMode mode) {
        chatPrefixMode = mode;
    }

    /**
     * Sets prefix mode for console messages.
     * 
     * @param mode the prefix mode
     */
    public static void setConsolePrefixMode(PrefixMode mode) {
        consolePrefixMode = mode;
    }

    /**
     * Sets custom prefix for CUSTOM mode.
     * 
     * @param prefix the custom prefix
     */
    public static void setCustomPrefix(String prefix) {
        customPrefix = prefix;
    }

    /**
     * Sets default target for messages.
     * 
     * @param target the default target
     */
    public static void setDefaultTarget(Target target) {
        defaultTarget = target;
    }

    /**
     * Gets default target for messages.
     * 
     * @return the default target
     */
    public static Target getDefaultTarget() {
        return defaultTarget;
    }

    /**
     * Sets whether to strip formatting from console output.
     * 
     * @param strip true to strip formatting
     */
    public static void setConsoleStripFormatting(boolean strip) {
        consoleStripFormatting = strip;
    }

    /**
     * Sets whether to use gradient for console prefix.
     * 
     * @param useGradient true to use gradient
     */
    public static void setConsoleUseGradient(boolean useGradient) {
        consoleUseGradient = useGradient;
    }

    private static final MiniMessage mm = MiniMessage.miniMessage();
    private static final LegacyComponentSerializer LEGACY = LegacyComponentSerializer.builder()
            .character('&')
            .hexColors()
            .useUnusualXRepeatedCharacterHexFormat()
            .build();

    private static final Map<String, PrefixedLogger> prefixedLoggers = new HashMap<>();

    /**
     * Default constructor (not used).
     */
    private Logger() {
    }

    /**
     * Initializes the logger with the plugin and configuration manager.
     * 
     * @param plugin  the JavaPlugin instance
     * @param manager the configuration manager
     */
    public static void init(JavaPlugin plugin, ConfigManager manager) {
        Logger.pluginInstance = plugin;
        Logger.configManager = manager;
        Logger.config = manager.register(LoggerConfig.class);

        // Set plugin name if not already set
        if (config.getPluginName().isEmpty()) {
            config.setPluginName(plugin.getName());
        }

        // Generate short name if not set
        if (config.getShortName().isEmpty()) {
            config.setShortName(generateShortName(config.getPluginName()));
        }

        loadConfiguration();

        // Save config with updated values
        manager.save(LoggerConfig.class);

        // Listen for config changes
        manager.onChange(LoggerConfig.class, (cfg, sections) -> {
            config = cfg;
            loadConfiguration();
        });
    }

    /**
     * Reloads the logger configuration.
     */
    public static void reload() {
        if (config != null) {
            loadConfiguration();
        }
    }

    /**
     * Load all settings from configuration
     */
    private static void loadConfiguration() {
        if (config == null)
            return;

        // Load prefix settings
        if (config.getPrefix() != null) {
            chatPrefixMode = config.getChatPrefixMode();
            consolePrefixMode = config.getConsolePrefixMode();
            customPrefix = config.getPrefix().getCustom();
            consoleUseGradient = config.getPrefix().isUseGradientConsole();
        }

        // Load default settings
        if (config.getDefaults() != null) {
            defaultTarget = config.getDefaultTarget();
        }

        // Load console settings
        if (config.getConsole() != null) {
            consoleStripFormatting = config.getConsole().isStripFormatting();
        }

        if (config.getChat().isAutoGenerateColors()) {
            generateChatColors();
        } else {
            loadChatColorsFromConfig();
        }

        if (config.getConsole().isAutoGenerateColors()) {
            generateConsoleColors();
        } else {
            loadConsoleColorsFromConfig();
        }

        // Load sub-logger configurations
        loadSubLoggers();
    }

    /**
     * Generate chat colors automatically
     */
    private static void generateChatColors() {
        String[] baseColors = ColorUtils.getMainAndSecondaryColor(config.getPluginName());
        chatDefaultGradient = baseColors;
        chatErrorColors = new String[] { "#ff4444", ColorUtils.adjustHue(baseColors[0], -30) };
        chatWarnColors = new String[] { "#ffaa00", ColorUtils.adjustHue(baseColors[0], 45) };
        chatDebugColors = new String[] { "#00aaff", ColorUtils.adjustHue(baseColors[0], 180) };
        chatSuccessColors = new String[] { "#00ff44", ColorUtils.adjustHue(baseColors[0], 120) };
    }

    /**
     * Generate console colors automatically
     */
    private static void generateConsoleColors() {
        String[] baseColors = ColorUtils.getMainAndSecondaryColor(config.getPluginName());
        consoleDefaultGradient = new String[] {
                ColorUtils.adjustBrightness(baseColors[0], 1.2f),
                ColorUtils.adjustBrightness(baseColors[1], 1.2f)
        };
        consoleErrorColors = new String[] { "#ff6666", ColorUtils.adjustHue(baseColors[0], -20) };
        consoleWarnColors = new String[] { "#ffcc22", ColorUtils.adjustHue(baseColors[0], 55) };
        consoleDebugColors = new String[] { "#22aaff", ColorUtils.adjustHue(baseColors[0], 170) };
        consoleSuccessColors = new String[] { "#22ff66", ColorUtils.adjustHue(baseColors[0], 110) };
    }

    /**
     * Load chat colors from configuration
     */
    private static void loadChatColorsFromConfig() {
        var gradient = config.getChatGradient();
        if (gradient != null) {
            chatDefaultGradient = gradient;
        }

        var errorColors = config.getChatColors("error");
        if (errorColors != null) {
            chatErrorColors = errorColors;
        }

        var warnColors = config.getChatColors("warn");
        if (warnColors != null) {
            chatWarnColors = warnColors;
        }

        var debugColors = config.getChatColors("debug");
        if (debugColors != null) {
            chatDebugColors = debugColors;
        }

        var successColors = config.getChatColors("success");
        if (successColors != null) {
            chatSuccessColors = successColors;
        }
    }

    /**
     * Load console colors from configuration
     */
    private static void loadConsoleColorsFromConfig() {
        var gradient = config.getConsoleGradient();
        if (gradient != null) {
            consoleDefaultGradient = gradient;
        }

        var errorColors = config.getConsoleColors("error");
        if (errorColors != null) {
            consoleErrorColors = errorColors;
        }

        var warnColors = config.getConsoleColors("warn");
        if (warnColors != null) {
            consoleWarnColors = warnColors;
        }

        var debugColors = config.getConsoleColors("debug");
        if (debugColors != null) {
            consoleDebugColors = debugColors;
        }

        var successColors = config.getConsoleColors("success");
        if (successColors != null) {
            consoleSuccessColors = successColors;
        }
    }

    /**
     * Generate short name from plugin name
     */
    private static String generateShortName(String name) {
        StringBuilder sb = new StringBuilder();
        Pattern pattern = Pattern.compile("[A-Z]");
        Matcher matcher = pattern.matcher(name);

        while (matcher.find() && sb.length() < 3) {
            sb.append(matcher.group());
        }

        if (sb.length() < 2) {
            sb = new StringBuilder();
            String[] words = name.split("(?=[A-Z])|[\\s_-]+");
            for (String word : words) {
                if (!word.isEmpty() && sb.length() < 3) {
                    sb.append(word.charAt(0));
                }
            }
        }

        return sb.toString().toUpperCase();
    }

    /**
     * Universal send method for logging messages with complete control over
     * delivery.
     * 
     * @param level        the log level (INFO, WARN, ERROR, DEBUG, SUCCESS)
     * @param message      the message to log (any Object)
     * @param player       single recipient player (can be null)
     * @param players      collection of recipient players (can be null or empty)
     * @param target       where to send (CHAT, CONSOLE, BOTH)
     * @param broadcast    if true, sends to all online players (ignoring
     *                     player/players params)
     * @param placeholders the placeholders to apply to the message
     */
    public static void send(
            LogLevel level,
            Object message,
            @Nullable Player player,
            @Nullable Collection<? extends Player> players,
            Target target,
            boolean broadcast,
            Object... placeholders) {

        // Process the message into Component
        Component component = parseMessage(message, level, target, player, players, placeholders);

        // Determine recipients
        Collection<CommandSender> recipients = determineRecipients(player, players, broadcast, target);

        // Deliver the message
        deliverMessage(component, recipients, target);
    }

    /**
     * Creates a fluent log builder for info level messages.
     * 
     * @return a new LogBuilder instance for chaining
     */
    public static LogBuilder log() {
        return new LogBuilder(LogLevel.INFO);
    }

    /**
     * Creates a fluent log builder for info level messages with no prefix.
     * 
     * @return a new LogBuilder instance for chaining
     */
    public static LogBuilder noPrefix() {
        return new LogBuilder(LogLevel.INFO).noPrefix();
    }

    /**
     * Creates a fluent log builder for info level messages.
     * 
     * @return a new LogBuilder instance for chaining
     */
    public static LogBuilder info() {
        return new LogBuilder(LogLevel.INFO);
    }

    /**
     * Creates a fluent log builder for warning level messages.
     * 
     * @return a new LogBuilder instance for chaining
     */
    public static LogBuilder warn() {
        return new LogBuilder(LogLevel.WARN);
    }

    /**
     * Creates a fluent log builder for error level messages.
     * 
     * @return a new LogBuilder instance for chaining
     */
    public static LogBuilder error() {
        return new LogBuilder(LogLevel.ERROR);
    }

    /**
     * Creates a fluent log builder for debug level messages.
     * 
     * @return a new LogBuilder instance for chaining
     */
    public static LogBuilder debug() {
        return new LogBuilder(LogLevel.DEBUG);
    }

    /**
     * Creates a fluent log builder for success level messages.
     * 
     * @return a new LogBuilder instance for chaining
     */
    public static LogBuilder success() {
        return new LogBuilder(LogLevel.SUCCESS);
    }

    /**
     * Creates a new logger instance with custom prefix.
     * Usage: Logger.create("MyModule").info("Hello")
     * 
     * @param name the name of the prefixed logger
     * @return a new PrefixedLogger instance
     */
    public static PrefixedLogger create(String name) {
        return withPrefix(name);
    }

    /**
     * Creates a new logger instance with custom name and prefix.
     * Usage: Logger.create("MyModule", "[MODULE]").info("Hello")
     * 
     * @param name   the name of the prefixed logger
     * @param prefix the custom prefix to use in messages
     * @return a new PrefixedLogger instance
     */
    public static PrefixedLogger create(String name, String prefix) {
        return withPrefix(name, prefix);
    }

    /**
     * Parses any Object into a formatted Component with prefix based on settings.
     */
    private static Component parseMessage(
            Object message,
            LogLevel level,
            Target target,
            @Nullable Player directPlayer,
            @Nullable Collection<? extends Player> playerCollection,
            Object... placeholdersArgs) {
        // First, convert Object to string representation
        String messageStr;
        Player singlePlayer = null;

        if (message instanceof Component) {
            // If already a Component, serialize to MiniMessage format
            messageStr = mm.serialize((Component) message);
        } else if (message instanceof Throwable) {
            // Format exception with stack trace
            messageStr = formatThrowable((Throwable) message);
        } else {
            // Use String.valueOf for any other object
            messageStr = String.valueOf(message);
        }

        if (placeholdersArgs != null && placeholdersArgs.length > 0) {
            Object lastArg = placeholdersArgs[placeholdersArgs.length - 1];
            if (lastArg instanceof Player) {
                singlePlayer = (Player) lastArg;
            }
        }

        if (directPlayer != null) {
            singlePlayer = directPlayer;
        }

        Player targetPlayer = singlePlayer != null ? singlePlayer
                : PlaceholderProcessor.pickPrimaryPlayer(directPlayer, playerCollection);

        messageStr = PlaceholderProcessor.applyPlaceholders(pluginInstance, targetPlayer, messageStr, placeholdersArgs);
        messageStr = PlaceholderProcessor.applyPapi(pluginInstance, messageStr, targetPlayer);
        messageStr = applyLocalization(messageStr);
        messageStr = PlaceholderProcessor.applyPapi(pluginInstance, messageStr, targetPlayer);
        messageStr = PlaceholderProcessor.applyPlaceholders(pluginInstance, targetPlayer, messageStr, placeholdersArgs);
        messageStr = ColorUtils.legacyToMiniMessage(messageStr);

        // Build prefix based on target
        String prefix = "";
        if (target == Target.CONSOLE || target == Target.BOTH) {
            prefix = buildPrefix(level, consolePrefixMode, true);
        } else {
            prefix = buildPrefix(level, chatPrefixMode, false);
        }

        // Combine prefix and message
        String finalMessage = prefix.isEmpty() ? messageStr : prefix + " " + messageStr;

        // Apply gradient if needed
        if (!prefix.isEmpty() && shouldUseGradient(target)) {
            String[] colors = getColorsForLevel(level, target == Target.CONSOLE);
            String gradientTag = ColorUtils.createGradientTag(colors);
            finalMessage = "<reset>" + gradientTag + finalMessage + "</gradient>";
        } else {
            finalMessage = "<reset>" + finalMessage;
        }

        // Parse to Component
        Component component = mm.deserialize(finalMessage, TagResolver.standard());

        // Strip formatting for console if needed
        if ((target == Target.CONSOLE || target == Target.BOTH) && consoleStripFormatting) {
            component = Component.text(PlainTextComponentSerializer.plainText().serialize(component));
        }

        return component;
    }

    /**
     * Formats a Throwable into a readable string with stack trace.
     */
    private static String formatThrowable(Throwable throwable) {
        StringBuilder sb = new StringBuilder();
        sb.append("<red>").append(throwable.getClass().getSimpleName()).append(": ")
                .append(throwable.getMessage()).append("</red>\n");

        for (StackTraceElement element : throwable.getStackTrace()) {
            sb.append("<gray>  at ").append(element.toString()).append("</gray>\n");
        }

        if (throwable.getCause() != null) {
            sb.append("<yellow>Caused by: </yellow>");
            sb.append(formatThrowable(throwable.getCause()));
        }

        return sb.toString();
    }

    /**
     * Applies localization to a message string.
     * 
     * @param messageStr the message string to localize
     * @return the localized message string
     */
    private static String applyLocalization(String messageStr) {
        if (config != null && config.isAutoLocalization() && languageManager != null && messageStr != null
                && messageStr.startsWith("@")) {
            String localized = languageManager.getMessage(messageStr.substring(1));
            if (!localized.equals(messageStr)) {
                return localized;
            }
        }
        return messageStr;
    }

    /**
     * Builds the prefix string based on mode and level.
     */
    private static String buildPrefix(LogLevel level, PrefixMode mode, boolean forConsole) {
        if (mode == PrefixMode.NONE) {
            return "";
        }

        String prefixText;
        switch (mode) {
            case SHORT:
                prefixText = config != null ? config.getShortName() : "UAP";
                break;
            case FULL:
                prefixText = config != null ? config.getPluginName() : "UnknownPlugin";
                break;
            case CUSTOM:
                prefixText = customPrefix;
                break;
            default:
                prefixText = "";
        }

        // For levels other than INFO, append the level name
        if (level != LogLevel.INFO) {
            prefixText = prefixText + " " + level.name();
        }

        return "[" + prefixText + "]";
    }

    /**
     * Determines if gradient should be used based on target.
     */
    private static boolean shouldUseGradient(Target target) {
        if (target == Target.CONSOLE) {
            return consoleUseGradient;
        } else if (target == Target.CHAT) {
            return config != null && config.getPrefix() != null && config.getPrefix().isUseGradientChat();
        }
        return true; // Default for BOTH
    }

    /**
     * Determines the recipients based on parameters.
     */
    private static Collection<CommandSender> determineRecipients(
            @Nullable Player player,
            @Nullable Collection<? extends Player> players,
            boolean broadcast,
            Target target) {

        // Console doesn't need recipients
        if (target == Target.CONSOLE) {
            return Collections.emptyList();
        }

        // Broadcast to all
        if (broadcast) {
            return new ArrayList<>(Bukkit.getOnlinePlayers());
        }

        // Collect recipients
        List<CommandSender> recipients = new ArrayList<>();

        if (player != null) {
            recipients.add(player);
        }

        if (players != null && !players.isEmpty()) {
            recipients.addAll(players);
        }

        return recipients;
    }

    /**
     * Delivers the message to recipients in a thread-safe manner.
     */
    private static void deliverMessage(Component component, Collection<CommandSender> recipients, Target target) {
        if (target == Target.CONSOLE || target == Target.BOTH) {
            Bukkit.getConsoleSender().sendMessage(component);
        }

        if (target == Target.CHAT || target == Target.BOTH) {
            if (!recipients.isEmpty()) {
                if (Bukkit.isPrimaryThread()) {
                    recipients.forEach(r -> r.sendMessage(component));
                } else {
                    Bukkit.getScheduler().runTask(pluginInstance,
                            () -> recipients.forEach(r -> r.sendMessage(component)));
                }
            }
        }
    }

    /**
     * Map of legacy color codes to MiniMessage codes.
     */
    private static final Map<Character, String> LEGACY_TO_MM = Map.ofEntries(
            Map.entry('0', "<black>"),
            Map.entry('1', "<dark_blue>"),
            Map.entry('2', "<dark_green>"),
            Map.entry('3', "<dark_aqua>"),
            Map.entry('4', "<dark_red>"),
            Map.entry('5', "<dark_purple>"),
            Map.entry('6', "<gold>"),
            Map.entry('7', "<gray>"),
            Map.entry('8', "<dark_gray>"),
            Map.entry('9', "<blue>"),
            Map.entry('a', "<green>"),
            Map.entry('b', "<aqua>"),
            Map.entry('c', "<red>"),
            Map.entry('d', "<light_purple>"),
            Map.entry('e', "<yellow>"),
            Map.entry('f', "<white>"),
            Map.entry('k', "<obfuscated>"),
            Map.entry('l', "<bold>"),
            Map.entry('m', "<strikethrough>"),
            Map.entry('n', "<underlined>"),
            Map.entry('o', "<italic>"),
            Map.entry('r', "<reset>"));

    /**
     * Converts legacy color codes to MiniMessage codes.
     * 
     * @param in the string to convert
     * @return the converted string
     */
    private static String legacyToMiniMessage(String in) {
        if (in == null || in.isEmpty())
            return in;

        String s = in.replace('ยง', '&');

        StringBuilder out = new StringBuilder(s.length() + 16);
        for (int i = 0; i < s.length();) {
            if (i + 13 < s.length()
                    && s.charAt(i) == '&'
                    && (s.charAt(i + 1) == 'x' || s.charAt(i + 1) == 'X')
                    && s.charAt(i + 2) == '&' && s.charAt(i + 4) == '&'
                    && s.charAt(i + 6) == '&' && s.charAt(i + 8) == '&'
                    && s.charAt(i + 10) == '&' && s.charAt(i + 12) == '&') {

                char a = s.charAt(i + 3), b = s.charAt(i + 5), c = s.charAt(i + 7),
                        d = s.charAt(i + 9), e = s.charAt(i + 11), f = s.charAt(i + 13);
                String hex = ("" + a + b + c + d + e + f).toLowerCase();
                out.append("<#").append(hex).append(">");
                i += 14;
                continue;
            }
            if (i + 7 <= s.length() && s.charAt(i) == '&' && s.charAt(i + 1) == '#') {
                String hex = s.substring(i + 2, i + 8);
                if (hex.matches("(?i)[0-9a-f]{6}")) {
                    out.append("<#").append(hex).append(">");
                    i += 8;
                    continue;
                }
            }
            if (i + 1 < s.length() && s.charAt(i) == '&') {
                char code = Character.toLowerCase(s.charAt(i + 1));
                String tag = LEGACY_TO_MM.get(code);
                if (tag != null) {
                    out.append(tag);
                    i += 2;
                    continue;
                }
            }
            out.append(s.charAt(i++));
        }
        return out.toString();
    }

    /**
     * Parses a string into a Component with smart parsing.
     * 
     * @param input the string to parse
     * @return the parsed Component
     */
    public static Component parseSmart(String input) {
        if (input == null || input.isEmpty())
            return Component.empty();
        boolean hasMini = input.indexOf('<') >= 0 && input.indexOf('>') > input.indexOf('<');
        boolean hasLegacy = input.indexOf('&') >= 0 || input.indexOf('ยง') >= 0;
        if (hasMini && hasLegacy) {
            return mm.deserialize(legacyToMiniMessage(input));
        } else if (hasMini) {
            return mm.deserialize(input);
        } else if (hasLegacy) {
            return LEGACY.deserialize(input.replace('ยง', '&'));
        }
        return Component.text(input);
    }

    /**
     * Get colors array for specific log level
     */
    private static String[] getColorsForLevel(LogLevel level, boolean forConsole) {
        if (forConsole) {
            return switch (level) {
                case ERROR -> consoleErrorColors;
                case WARN -> consoleWarnColors;
                case DEBUG -> consoleDebugColors;
                case SUCCESS -> consoleSuccessColors;
                default -> consoleDefaultGradient;
            };
        } else {
            return switch (level) {
                case ERROR -> chatErrorColors;
                case WARN -> chatWarnColors;
                case DEBUG -> chatDebugColors;
                case SUCCESS -> chatSuccessColors;
                default -> chatDefaultGradient;
            };
        }
    }

    /**
     * Load prefixed logger configurations from config
     */
    private static void loadSubLoggers() {
        if (config == null || config.getSubLoggers() == null)
            return;

        for (Map.Entry<String, SubLoggerConfig> entry : config.getSubLoggers().entrySet()) {
            PrefixedLogger existing = prefixedLoggers.get(entry.getKey());
            if (existing != null) {
                existing.setEnabled(entry.getValue().isEnabled());
            }
        }
    }

    /**
     * Creates or gets a logger with custom prefix
     * 
     * @param name the name of the logger
     * @return the prefixed logger instance
     */
    public static PrefixedLogger withPrefix(String name) {
        return withPrefix(name, "[" + name + "]");
    }

    /**
     * Creates or gets a logger with custom prefix
     * 
     * @param name   the name of the logger
     * @param prefix the prefix to use
     * @return the prefixed logger instance
     */
    public static PrefixedLogger withPrefix(String name, String prefix) {
        return prefixedLoggers.computeIfAbsent(name, k -> {
            PrefixedLogger prefixedLogger = new PrefixedLogger(name, prefix);

            // Check if there's a configuration for this logger
            if (config != null && config.getSubLoggers() != null) {
                SubLoggerConfig subLoggerConfig = config.getSubLoggers().get(name);
                if (subLoggerConfig != null) {
                    prefixedLogger.setEnabled(subLoggerConfig.isEnabled());
                }
            }

            return prefixedLogger;
        });
    }

    /**
     * Gets all registered prefixed loggers
     * 
     * @return map of logger names to instances
     */
    public static Map<String, PrefixedLogger> getPrefixedLoggers() {
        return new HashMap<>(prefixedLoggers);
    }

    /**
     * Sets the enabled state of a prefixed logger
     * 
     * @param name    the name of the logger
     * @param enabled true to enable, false to disable
     */
    public static void setPrefixedLoggerEnabled(String name, boolean enabled) {
        PrefixedLogger logger = prefixedLoggers.get(name);
        if (logger != null) {
            logger.setEnabled(enabled);
        }
    }

    /**
     * Target destination for log messages.
     */
    public enum Target {
        /** Send only to chat (players). */
        CHAT,
        /** Send only to console. */
        CONSOLE,
        /** Send to both chat and console. */
        BOTH
    }

    /**
     * Prefix display mode.
     */
    public enum PrefixMode {
        /** No prefix. */
        NONE,
        /** Short prefix (e.g., "ABC"). */
        SHORT,
        /** Full prefix (e.g., "AwesomeBukkitPlugin"). */
        FULL,
        /** Custom prefix from configuration. */
        CUSTOM
    }

    /**
     * Logging levels enumeration.
     */
    public enum LogLevel {
        /** Info log level. */
        INFO("INFO"),
        /** Warn log level. */
        WARN("WARN"),
        /** Error log level. */
        ERROR("ERROR"),
        /** Debug log level. */
        DEBUG("DEBUG"),
        /** Success log level. */
        SUCCESS("SUCCESS");

        private final String displayName;

        LogLevel(String displayName) {
            this.displayName = displayName;
        }

        /**
         * Gets the display name of the log level.
         * 
         * @return the display name
         */
        public String getDisplayName() {
            return displayName;
        }
    }
}
